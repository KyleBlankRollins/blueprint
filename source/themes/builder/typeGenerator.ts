/**
 * Type generation utilities
 * Generates TypeScript declaration files for registered colors and theme variants
 */

import type { ColorDefinition } from '../core/types.js';

/**
 * Configuration for type generation
 */
export interface TypeGenerationConfig {
  /** Output file path for generated types */
  outputPath: string;
  /** Include JSDoc comments in generated types */
  includeJSDoc?: boolean;
  /** Module name for imports (e.g., '@blueprint/themes') */
  moduleName?: string;
}

/**
 * Generate TypeScript declaration file content for registered colors
 *
 * @param colors - Map of color names to their definitions
 * @param config - Type generation configuration
 * @returns TypeScript declaration file content
 * @throws {Error} If no colors are registered or color names/definitions are invalid
 *
 * @example
 * ```typescript
 * const colors = new Map([
 *   ['gray', { source: {...}, scale: [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950] }],
 *   ['blue', { source: {...}, scale: [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950] }]
 * ]);
 *
 * const typeContent = generateColorTypes(colors);
 * // Generated content includes ColorRegistry interface with all color+step combinations
 * ```
 */
export function generateColorTypes(
  colors: Map<string, ColorDefinition>,
  config: TypeGenerationConfig = { outputPath: '', includeJSDoc: true }
): string {
  // Validate inputs
  if (colors.size === 0) {
    throw new Error('Cannot generate types: no colors registered');
  }

  // Validate color names and definitions
  for (const [name, definition] of colors.entries()) {
    if (!/^[a-z][a-zA-Z0-9-]*$/.test(name)) {
      throw new Error(
        `Invalid color name "${name}": must start with lowercase letter and contain only letters, numbers, and hyphens`
      );
    }
    if (!definition.scale || definition.scale.length === 0) {
      throw new Error(`Color "${name}" has no scale steps`);
    }
  }

  const lines: string[] = [];

  // File header
  lines.push('/**');
  lines.push(' * Auto-generated theme color types');
  lines.push(
    ' * DO NOT EDIT MANUALLY - This file is generated by ThemeBuilder'
  );
  lines.push(' */');
  lines.push('');

  // Import ColorRef type
  if (config.moduleName) {
    lines.push(`import type { ColorRef } from '${config.moduleName}';`);
  } else {
    lines.push("import type { ColorRef } from '../core/types.js';");
  }
  lines.push('');

  // Generate color name union type
  const colorNames = Array.from(colors.keys()).sort();
  if (config.includeJSDoc) {
    lines.push('/**');
    lines.push(' * Available color names in the theme');
    lines.push(' */');
  }
  lines.push('export type ColorName =');
  colorNames.forEach((name, index) => {
    const isLast = index === colorNames.length - 1;
    lines.push(`  | '${name}'${isLast ? ';' : ''}`);
  });
  lines.push('');

  // Generate color step type from standard steps
  if (config.includeJSDoc) {
    lines.push('/**');
    lines.push(' * Valid color scale steps');
    lines.push(' */');
  }
  lines.push(
    'export type ColorScaleStep = 50 | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | 950;'
  );
  lines.push('');

  // Generate individual color scale types
  for (const [colorName, definition] of colors.entries()) {
    const steps = [...definition.scale].sort((a, b) => a - b);

    if (config.includeJSDoc) {
      lines.push('/**');
      lines.push(` * Color scale for ${colorName}`);
      if (definition.metadata?.description) {
        lines.push(` * ${definition.metadata.description}`);
      }
      lines.push(' */');
    }

    lines.push(`export interface ${toPascalCase(colorName)}ColorScale {`);
    for (const step of steps) {
      lines.push(`  /** ${colorName} at ${step} lightness step */`);
      lines.push(`  ${colorName}${step}: ColorRef;`);
    }
    lines.push('}');
    lines.push('');
  }

  // Generate ColorRegistry interface that combines all color scales
  if (config.includeJSDoc) {
    lines.push('/**');
    lines.push(' * Complete registry of all available colors and their steps');
    lines.push(
      ' * Access via builder.colors.colorNameStep (e.g., builder.colors.gray50)'
    );
    lines.push(' */');
  }
  lines.push('export interface ColorRegistry');

  // Extend all color scale interfaces
  const scaleInterfaces = colorNames.map(
    (name) => `${toPascalCase(name)}ColorScale`
  );
  lines.push(`  extends ${scaleInterfaces.join(',\n    ')} {}`);
  lines.push('');

  // Generate color reference string type for serialization
  if (config.includeJSDoc) {
    lines.push('/**');
    lines.push(' * String representation of color references');
    lines.push(' * Format: "colorName.step" (e.g., "gray.50", "blue.500")');
    lines.push(' */');
  }
  lines.push('export type ColorRefString = `${ColorName}.${ColorScaleStep}`;');
  lines.push('');

  // Generate helper type for theme variant color values
  if (config.includeJSDoc) {
    lines.push('/**');
    lines.push(' * Type-safe color value for theme variants');
    lines.push(' * Can be either a ColorRef object or a ColorRefString');
    lines.push(' */');
  }
  lines.push('export type ThemeColorValue = ColorRef | ColorRefString;');
  lines.push('');

  // Add module augmentation for ThemeBuilder
  lines.push('/**');
  lines.push(' * Augment ThemeBuilder with typed color registry');
  lines.push(' */');
  lines.push("declare module '../builder/ThemeBuilder.js' {");
  lines.push('  interface ThemeBuilder {');
  lines.push('    /**');
  lines.push('     * Typed color registry with auto-complete support');
  lines.push(
    '     * Access colors like: builder.colors.gray50, builder.colors.blue500'
  );
  lines.push('     */');
  lines.push('    readonly colors: ColorRegistry;');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate color scale type for a specific color
 *
 * @param colorName - Name of the color
 * @param steps - Array of scale steps
 * @returns TypeScript interface definition
 *
 * @example
 * ```typescript
 * const scaleType = generateColorScaleType('gray', [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950]);
 * // Returns: "export interface GrayColorScale { gray50: ColorRef; gray100: ColorRef; ... }"
 * ```
 */
export function generateColorScaleType(
  colorName: string,
  steps: readonly number[]
): string {
  const lines: string[] = [];

  lines.push(`export interface ${toPascalCase(colorName)}ColorScale {`);
  for (const step of steps) {
    lines.push(`  ${colorName}${step}: ColorRef;`);
  }
  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate ColorRegistry type that includes all registered colors
 *
 * @param colorNames - Array of color names
 * @returns TypeScript type definition
 *
 * @example
 * ```typescript
 * const registryType = generateColorRegistryType(['gray', 'blue', 'red']);
 * // Returns: "export type ColorRegistry = GrayColorScale & BlueColorScale & RedColorScale"
 * ```
 */
export function generateColorRegistryType(colorNames: string[]): string {
  if (colorNames.length === 0) {
    return 'export type ColorRegistry = Record<never, never>;';
  }

  const scaleTypes = colorNames
    .map((name) => `${toPascalCase(name)}ColorScale`)
    .join(' & ');

  return `export type ColorRegistry = ${scaleTypes};`;
}

/**
 * Generate theme variant types with type-safe color references
 *
 * @param variantNames - Array of theme variant names
 * @param config - Type generation configuration
 * @returns TypeScript declaration content
 *
 * @example
 * ```typescript
 * const variantTypes = generateThemeVariantTypes(['light', 'dark', 'ocean']);
 * // Generates union type and individual variant interfaces
 * ```
 */
export function generateThemeVariantTypes(
  variantNames: string[],
  config: TypeGenerationConfig = { outputPath: '', includeJSDoc: true }
): string {
  const lines: string[] = [];

  if (variantNames.length === 0) {
    return '';
  }

  // Generate variant name union type
  if (config.includeJSDoc) {
    lines.push('/**');
    lines.push(' * Available theme variant names');
    lines.push(' */');
  }
  lines.push('export type ThemeVariantName =');
  variantNames.forEach((name, index) => {
    const isLast = index === variantNames.length - 1;
    lines.push(`  | '${name}'${isLast ? ';' : ''}`);
  });
  lines.push('');

  return lines.join('\n');
}

/**
 * Write generated types to a file
 *
 * @param content - Generated TypeScript content
 * @param outputPath - Path to write the file
 * @returns Promise that resolves when file is written
 * @throws {Error} If file write fails or directory cannot be created
 */
export async function writeTypeFile(
  content: string,
  outputPath: string
): Promise<void> {
  // Use dynamic imports for Node.js modules to avoid bundling issues
  // This is a server-side only function used by CLI/build tools
  const { writeFile, mkdir } = await import('fs/promises');
  const { dirname } = await import('path');

  // Ensure directory exists
  const dir = dirname(outputPath);
  await mkdir(dir, { recursive: true });

  // Write file
  await writeFile(outputPath, content, 'utf-8');
}

/**
 * Convert kebab-case or camelCase to PascalCase
 *
 * @param str - String to convert
 * @returns PascalCase string
 *
 * @example
 * ```typescript
 * toPascalCase('ocean-blue') // => 'OceanBlue'
 * toPascalCase('oceanBlue')  // => 'OceanBlue'
 * toPascalCase('gray')       // => 'Gray'
 * ```
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

/**
 * Generate complete type declarations for a theme configuration
 *
 * @param colors - Map of color names to definitions
 * @param themeVariantNames - Array of theme variant names
 * @param config - Type generation configuration
 * @returns Complete TypeScript declaration content
 * @throws {Error} If no colors are registered or color names/definitions are invalid
 *
 * @example
 * ```typescript
 * const typeContent = generateCompleteTypes(colorsMap, ['light', 'dark'], {
 *   outputPath: 'source/themes/generated/theme.d.ts',
 *   includeJSDoc: true
 * });
 * await writeTypeFile(typeContent, 'source/themes/generated/theme.d.ts');
 * ```
 */
export function generateCompleteTypes(
  colors: Map<string, ColorDefinition>,
  themeVariantNames: string[],
  config: TypeGenerationConfig
): string {
  const parts: string[] = [];

  // Generate color types
  parts.push(generateColorTypes(colors, config));

  // Generate theme variant types
  if (themeVariantNames.length > 0) {
    parts.push(generateThemeVariantTypes(themeVariantNames, config));
  }

  return parts.join('\n');
}
